__author__ = 'Paarth Bhasin'

import threading
import os
import subprocess as sp
import queue
from DoubleLinkedList import LinkedList

result_queue1 = queue.Queue()
result_queue2 = queue.Queue()
'''
We import LinkedList from DoubleLinkedList which is a doubly linked list.
We import the threading module two run the two threads, namely: Clock() and LRU()
We import the os and subprocess modules to execute the functions: cmd_help() and cmd_programdoc()
'''

npages = 0
# ^The maximum number in the entire reference string, set to be 0 initially.

lock = threading.Lock()
# We use locking so that the two threads don't interfere with using the same dictionary: pagetoframe and the same
# array: frametopage.

frametopage = [0] * 3
# ^This is a reference from a frame to the page it contains currently, once the page replacement algorithm has
# started working.

pagetoframe = {}
# This (a dictionary) is a reference from a page to the frame it belongs to, at the current status of the frames
# undergoing the page replacement algorithm.


class ClockNode:
    def __init__(self, element=None, usebit=None):
        self.element = element
        self.usebit = usebit


# ^A ClockNode class. Each instance of this class is a page with an element and usebit. When the page is first loaded
# into the memory/frames, the usebit is set to 1. When a page(a ClockNode to be precise) is to be replaced by
# some other page(ClockNode as mentioned before), we find the first page that has the usebit of 0 and traverse the
# list in circular way, while doing so. If pages are encountered with usebit = 1 on the way, their usebit are reset to
# 0 and we keep moving on until we find the page with usebit = 0.

class Clock(threading.Thread):
    # ^Clock() thread.
    def __init__(self, r_queue):
        threading.Thread.__init__(self)
        self.result_queue = r_queue

    def run(self):
        lock.acquire()
        print("Clock Thread")
        pagetoframe.clear()
        # ^We clear the global dictionary we created in the beginning so that any changes made to it by the LRU() thread
        # are reverted back/undone.

        array = [None] * 3
        # ^Our local memory/buffer with 3 frames.

        faults = 0
        # ^This keeps track of the number of faults encountered while executing the Clock Replacement Algorithm.

        f = open('PageReferences.txt', 'r')
        # ^We open the file PageReferences.txt to read in the reference values of the reference string that was
        # generated by the page reference generator file: pagerefegen.py.

        lines = f.readlines()
        # ^The lines are read from the file PageReferences.txt and put in a variable called lines.

        line = lines[0]
        # ^Since the text file, namely: PageReferences.txt contains only one line, the first line, i.e.: lines[0] is
        # read and put in a variable called line. line[0] by itself contains spaces which would make it troublesome
        # to read the integer page values separately from itself.

        line = line.split()
        # ^The line which is a string is split by the .split() method to remove the spaces. By doing this, we
        # make line a list of elements which are pages, and hence list becomes iterable, which would help
        # us in referencing different values in the future.

        f.close()
        # The text file is closed because it doesn't serve any purpose anymore. We have read the values that were
        # present in the text file and we can't do anything else with it.

        mark = 0
        # ^A variable which keeps track of the position we are currently up to in the circular frame.

        replaced = False
        # ^A boolean variable which checks whether a fault has occurred or not. If it has, the variable takes the
        # value True. If it hasn't, the variable takes the value False.

        array[0] = ClockNode(int(line[0]), 1)
        frametopage[0] = int(line[0])
        pagetoframe[int(line[0])] = 0
        array[1] = ClockNode(int(line[1]), 1)
        frametopage[1] = int(line[1])
        pagetoframe[int(line[1])] = 1
        array[2] = ClockNode(int(line[2]), 1)
        frametopage[2] = int(line[2])
        pagetoframe[int(line[2])] = 2

        # ^We put the first three values of the reference string into the three frames of the circular buffer/memory.
        count = 0
        for i in range(3, len(line)):
            count += 1
            # print("count: " + str(count))
            # ^Since we used the first three values of the reference string already (index 0, 1, 2) , we start with
            # the integer value (page number) stored at index = 3 and go up to index = n - 1, where n is the length of
            # line or number of integers/page numbers in the reference string.

            replaced = False
            # In each iteration of the for-loop we encounter a fault, which makes replaced = True.
            # This stops the while loop(below). But to re-enter the while loop again in the next iteration of
            # the for-loop we need to reset the value of the variable replaced to False. That's exactly what we do
            # above.

            node = ClockNode(int(line[i]), 1)
            # ^Creating a node which would go into the memory/buffer, which would have the page number: line[i]
            # and the usebit of 1 (since it has been referenced recently).

            for j in range(len(array)):
                if array[j].element == node.element:
                    # print("yes!")

                    array[j].usebit = 1
                    replaced = True
                    break
            # print("Hey!")
            while not replaced:

                # If the element we are referencing is already there in the buffer/memory, we don't do anything.

                while array[mark].usebit != 0:
                    # ^Initially we start at mark = 0. And go around the buffer in a circular manner.
                    # All the elements (nodes) that we encounter along the way which have a usebit of 1
                    # are reset to have usebit of 0, and we carry on this process.

                    array[mark].usebit = 0
                    # ^Resetting the usebit attribute of the element/node we encounter, to 0.

                    mark = (mark + 1) % len(array)
                    # Incrementing mark so that it refers to indices of array in a circular manner.

                # If we are in this else condition, this means that we have found an element/node with usebit = 0
                # and this would the element which would be replaced by the page we are referencing currently
                # from the reference string.
                # print("Dictionary: " + str(pagetoframe))
                # print(mark)
                # print(array[mark].element)
                del pagetoframe[array[mark].element]
                # ^Since we are replacing the page we found with a usebit = 0, its page to frame reference needs to
                # be deleted. This is because that page would no longer belong to the frame number it was contained
                # in before. So we delete that entry from the pagetoframe dictionary.

                array[mark] = node
                # ^That is how we replace the page at mark (the page which has usebit = 1) with the page we are
                # currently referencing from the reference string/reference array(line).

                frametopage[mark] = node.element
                # ^Modifying the frame to page reference after we replace the page with the page we are referencing
                # from the reference string/array(line).

                pagetoframe[array[mark].element] = mark
                # ^Inserting a new page to frame reference. This new reference relates the new page we are loading
                # to the frame number it is being loaded at.

                faults += 1
                # Since a replacement of a page has occurred, we increase the number of faults by 1.

                replaced = True
                # We replaced a page and thus we put change the value of boolean variable 'replaced' to True.
                # This would make compiler break out of the while-loop it is currently in and take the for-loop to
                # its next iteration/state. But of course, as it was stated above, in the next iteration of the
                # for-loop, 'replaced' is again reset to take the value False, so that it can enter this while loop
                # again, in the next iteration of the for loop.

        # print(faults)
        # We print the number of faults that were encountered by executing the Clock Replacement algorithm.
        self.result_queue.put(faults)
        # We put the number of faults that were encountered by executing the Clock Replacement algorithm in the
        # result_queue by the .put() method. It would later be retrieved by the .get() method.
        lock.release()


class LRU(threading.Thread):
    # ^LRU() thread.
    def __init__(self, r_queue):
        threading.Thread.__init__(self)
        self.result_queue = r_queue

    def run(self):
        lock.acquire()
        print("LRU Thread")
        pagetoframe.clear()
        # ^We clear the global dictionary we created in the beginning so that any changes made to it by the Clock()
        # thread are reverted back/undone.

        faults = 0
        # ^This keeps track of the number of faults encountered while executing the LRU Replacement Algorithm.

        mark = 0
        # integers = []
        replaced = False
        f = open('PageReferences.txt', 'r')
        # ^We open the file PageReferences.txt to read in the reference values of the reference string that was
        # generated by the page reference generator file: pagerefegen.py.

        lines = f.readlines()
        # ^The lines are read from the file PageReferences.txt and put in a variable called lines.

        line = lines[0]
        # ^Since the text file, namely: PageReferences.txt contains only one line, the first line, i.e.: lines[0] is
        # read and put in a variable called line. line[0] by itself contains spaces which would make it troublesome
        # to read the integer page values separately from itself.

        line = line.split()
        # ^The line which is a string is split by the .split() method to remove the spaces. By doing this, we
        # make line a list of elements which are pages, and hence list becomes iterable, which would help
        # us in referencing different values in the future.

        f.close()
        # The text file is closed because it doesn't serve any purpose anymore. We have read the values that were
        # present in the text file and we can't do anything else with it.

        List = LinkedList()
        # ^Creating an instance of the LinkedList(), which functions like a doubly linked list.

        List.append()
        List.append()
        List.append()

        # ^Our local memory/buffer with 3 frames. It creates 3 nodes of doubly linked list 'List', each of which
        # are empty and don't contain anything in them. Basically, this is how we initialise the buffer when it is
        # represented by a doubly linked list.

        head = List.first
        # The first element of the doubly linked list. Its called head and would have the value 0 at this time because
        # the list doesn't contain anything right now.

        tail = List.last
        # The last element of the doubly linked list. Its called tail and would have the value 0 at this time because
        # the list doesn't contain anything right now.

        # print(List.count)
        # The size of the doubly linked list. It would print 3, which would mean there are 3 frames in the buffer
        # being used to implement the LRU algorithm.

        traverse = List.first
        # Pointer to the first(head) node of the list.

        traverse.element = int(line[0])
        # ^The head element contained the value 0 before, corresponding to index 0.
        # Now it contains the first element of the reference string or array(line).

        traverse.next.element = int(line[1])
        # The second element corresponding to index 1 of the doubly linked list: List. It contained 0 before, but now
        # it contains the second element of the reference string or array(line)

        traverse.next.next.element = int(line[2])
        # The second element corresponding to index 2 of the doubly linked list: List. It contained 0 before, but now
        # it contains the third element of the reference string or array(line)

        frametopage[0] = int(line[0])
        pagetoframe[int(line[0])] = 0
        frametopage[1] = int(line[1])
        pagetoframe[int(line[1])] = 1
        frametopage[2] = int(line[2])
        pagetoframe[int(line[2])] = 2

        # ^We put the first three values of the reference string into the three frames of the circular buffer/memory.

        for i in range(3, len(line)):
            # ^Since we used the first three values of the reference string already (index 0, 1, 2) , we start with
            # the integer value (page number) stored at index = 3 and go up to index = n - 1, where n is the length of
            # line or number of integers/page numbers in the reference string.

            # print("outer")
            mark = 0
            # ^A variable which keeps track of index position at which we found a similar occurrence in the buffer
            # of the page we are currently referencing.

            traverse = List.first
            # Pointer to the first element of the doubly linked list.

            replaced = False
            # ^A boolean variable which checks whether a fault has occurred or not. If it has, the variable takes the
            # value True. If it hasn't, the variable takes the value False.

            # print(line)
            element = int(line[i])
            # ^The element/page we are currently refrencing from the reference string/array.

            while traverse is not None:
                # ^Traverses the linked list to find the find the occurrence of the element we are currently referencing
                # , if it exists. 'mark' is incremented each time we do so.

                if traverse.element != element:
                    traverse = traverse.next
                    mark += 1

                else:
                    # If an occurrence has been found, we break out of the traversal while-loop.
                    break
            while not replaced:
                # ^While-loop executes until a fault occurs or unless a similar occurrence of the page we are currently
                # referencing is found (mark < 3 case).

                if mark < 3:
                    # This means that the page we are referencing is already present in the linked list and it does not
                    # need to be replaced. We just leave it as it is, in the position it was before. That's because
                    # even though we might think that as it has been referenced recently, it should be appended to the
                    # end of the list, but that is not true. If it was referenced and it was already existing in the
                    # memory, it means that it was referenced once before, and this reference is not going to change its
                    # time of reference. It was referenced some while ago and it has been in use since then.

                    # print("1")
                    replaced = True
                    # Even though we didn't actually replace the page, 'replaced' takes the value True, so that the
                    # compiler breaks out of the while-loop which executes on the status of the boolean variable:
                    # replaced.

                    continue
                    # Skips all following statements and returns to control to the beginning of the while-loop, making
                    # it go to its next state/iteration.

                else:
                    # If we enter this else-condition, it means that the page we are currently referencing doesn't exist
                    # in the linked list/buffer/memory. This means that we would have to replace the least recently used
                    # page with the page we are currently referencing, and hence a fault would occur.

                    # print("2")
                    pagetoframe.clear()
                    # We delete all the page to frame references of the pagetoframe dictionary. That's because we
                    # delete the least recently used page (which would shift all the nodes one position behind and add
                    # a new node to the list (which would change the page to frame reference again)

                    head = head.next
                    # head points to the next element because we are going to delete the the first one and it wouldn't
                    # exist anymore as a part of the linked list. If we don't do this, head would start pointing to
                    # None and that would make us lose track of what the first element of the list is.

                    List.delete(0)
                    # We delete the first element of the linked list.

                    List.append(element)
                    # We add/append the element/page we are referencing to the linked list.

                    pagetoframe[head.element] = 0
                    pagetoframe[head.next.element] = 1
                    pagetoframe[head.next.next.element] = 2
                    # We update the page to frame references.

                    tail = List.last
                    # Since we modified the linked list, we update the tail so that it correctly points to the the last
                    # element of the list.

                    faults += 1
                    # Since a replacement of a page has occurred, we increase the number of faults by 1.

                    replaced = True
                    # We change the condition of replaced to True because a fault has occurred. Doing this would make
                    # the compiler break out of the current while loop and we can carry on with the outer for-loop so
                    # as to go through the rest of the reference string/array(list).
        self.result_queue.put(faults)

        # We put the number of faults that were encountered by executing the LRU Replacement algorithm in the
        # result_queue by the .put() method. It would later be retrieved by the .get() method.
        lock.release()

def cmd_help():
    path = os.getcwd()
    sp.call(path + os.sep + "readme.txt", shell=True)

# The .getcwd() method of the os module returns the current working directory (cwd) of the process we are currently
# running and opens the readme.txt file in it, if it exists. Otherwise, it does nothing.

def cmd_program():
    path = os.getcwd()
    sp.call(path + os.sep + "Program Documentation.txt", shell=True)

# The .getcwd() method of the os module returns the current working directory (cwd) of the process we are currently
# running and opens the Program Documentation.txt file in it, if it exists. Otherwise, it does nothing.

def cmd_cls():
    sp.call('cls', shell=True)

# The .call('cls', shell=True) function of the module subprocess, clears the command line screen.

def main():
    quit = False
    # A variable which keeps track of whether the user wants to quit the program (True) or not (False).
    maximum = 0
    # A variable which holds the maximum number in the reference string.
    words = []
    # An empty array words. Though there's no use for it, but if we don't do this, a harmless error would creep up
    # on line 367, which would say that words might be used before reference. And that would just make the code look
    # ugly on screen.
    f = open('PageReferences.txt', 'r')
    # We open the file named PageReferences.txt and read all the lines from it(below).
    lines = f.readlines()

    for line in lines:
        words = line.split()
        # Lines contains spaces in it. So we get rid of those spaces and put the element in the list buy using the
        # .split() method.

    print(words)
    for i in range(len(words)):
        if int(words[i]) > maximum:
            maximum = int(words[i])
    # ^This is how we get the maximum number/integer present in the reference string.

    npages = maximum
    # And we set the maximum we found to the value 'npages' just like it says in the Assignment specs.

    while not quit:
        print("\nThis program compares the LRU and clock page replacement algorithms to the Optimal Page Replacement"
              " algorithm on the basis of the number of faults/page replacements experienced.\n")
        # ^A brief summary which displays on the screen what this program does.

        print("Commands: ")
        print("compare: Compare the LRU, Clock and Optimal page replacement algorithms with each Optimal")
        print("help: Open help file")
        print("clr: Clear screen")
        print("programdoc: Open program documentation")
        print("quit: Quit the program")
        # ^All the commands that the program can execute.

        choice = input("Enter command: ")
        # ^Prompting user for the command they want to enter.

        if choice == "compare":

            clock = Clock(result_queue1)
            lru = LRU(result_queue2)
            # ^Creating instances of the threads Clock() and LRU() respectively.

            clock.start()
            lru.start()
            # ^Starting the two threads.

            clockfaults = result_queue1.get()
            lrufaults = result_queue2.get()

            clock.join()
            lru.join()
            # ^Making sure the two threads end.

            print("Number of Faults in Clock Algorithm: " + str(clockfaults))
            print("Number of Faults in LRU Algorithm: " + str(lrufaults))
            print("Number of Faults in Optimal Algorithm: " + str(10))

        elif choice == "help":
            # If the user types "help", then the readme.txt file is opened
            # by calling the program: cmd_help(), which would assist
            # the user in understanding how this program works and how
            # to use it.
            cmd_help()

        elif choice == "quit":
            # If the user types "quit", then this program i.e. PageReplacementAlgorithms.py
            # simply ends.
            quit = True

        elif choice == "programdoc":
            # If the user types "programdoc", then the Program Documentation.txt file is opened
            # by calling the program: cmd_program(). It helps a Python Literate user/Programmer to understand
            # and maintain the program PageReplacementAlgorithms.py.
            cmd_program()

        elif choice == "clr":
            # If the user types "clr", then the command line screen in Python Shell in cleared by
            # calling the program: cmd_cls().
            cmd_cls()
        else:
            # If we end up in this else condition, it means the user has entered an invalid command and we display
            # an appropriate message to the user for the same.
            print("Invalid command.")


if __name__ == "__main__":
    # ^This line ensures that this program is being run from itself and not being run from some other file/not being
    # imported and run from some other file.
    main()
